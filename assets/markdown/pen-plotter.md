---
title: CoreXY Pen Plotter
thumbnail: /assets/images/pen-plotter.png
description: A coreXY kinematic pen plotter prototype for a design class
---

<div style="display: flex; justify-content: center; align-items: center;">
<img class="banner" src="/assets/images/pen-plotter/pen-plotter-banner.png" alt="Banner image">
</div>

# Pen Plotter

> ℹ️ INFO
>
> Status: Completed on October 24, 2024\
> Associated Course: EDNS 210 | Physical Prototyping\
> Project Type: Group | 3 People

## Context

For our third prototyping sprint in _Physical Prototyping_ we were tasked to
"stretch with technology". Our previous sprints had focused on mechanical
design and cardboard mockups but this time, we needed to incorporate a mechanical
and electronic component.

My group, inspired by the Bambu Lab printers in the makerspace just down the 
hall, decided to build a pen plotter with CoreXY kinematics. My job was to handle
the wiring, electronics, and firmware while my teammates handled the mechanical
design.

## Low Fidelity Prototype

I began by using the stepper motor and driver included in our Arduino kit to
familiarize myself with the basic concepts and libraries for controlling
stepper motors with a microcontroller.

Then, I switched over to the larger steppers and drivers that we had purchased
specifically for this project. My final low fidelity prototype simultaneously
moved two motors with two drivers as these were the primary motion components
for the plotter.

Finally, I drew up a wiring diagram for us to reference while assembling the
plotter, and to show our classmates for a design pinup.

<div class="image-caption">
<img src="/assets/images/pen-plotter/pen-plotter-1.png" alt="Wiring Diagram for Pinup">
<p>The system used an external 12 volt power supply and limit switches for homing</p>
</div>

## Getting Carried Away

With the low fidelity prototype complete, I got to work writing the motion
controller. Rather than use g-code, the controller expected a series of Bézier
curves to be sent over the Arduino's serial connection. With a defined maximum
velocity, these curves would be linearly interpolated and sampled at discrete
timesteps to provide target positions for the motors.

This didn't take very long and, while I was waiting for my teammates to complete
the mechanical design, I got a little carried away adding features. I even went
so far as to build a desktop GUI using `raylib` that would allow you to drag
and drop an SVG whose curves would automatically be sent to the Arduino one by 
one to draw the image.
<br>
<div class="image-caption">
<img src="/assets/images/pen-plotter/pen-plotter-2.png" alt="Desktop GUI with drag and drop prompt">
</div>
<br>
At the time, this felt like a natural extension of the controller. In retrospect,
it introduced complexity that was misaligned with the scope and timeline of the
project.

## The Weak Link

When the mechanical design was complete, manufactured, and assembled, we started
testing, and that's when the problems began.

Aside from tweaks to the physical parts that required lengthy reprints, there
were numerous software problems. The plotter could move between two points
smoothly (this had been tested in my earlier prototype), but the curve
interpolation functionality was plagued with bugs and jitter.

On top of that, all the other functionality that I had built was now getting in
the way, and making the debugging process much more difficult and much more
confusing. This got exponentially worse as more time passed and we felt more
pressure to have the prototype ready for presentation day.

I had designed such a complex system that my teammates, who weren't as
knowledgeable about code, couldn't provide much help with these problems. And so
I was left to my own devices to try to get everything working in time.

Eventually, I ended up having to ditch all those features I had built, and we
presented a robot that could only follow pre-programmed paths. It worked, but
it wasn't what I had originally envisioned.

<div style="display: flex; align-items: center; justify-content: center;">
<iframe width="560" 
height="315" 
src="https://www.youtube.com/embed/4tKHTWxPI9g?si=nm0nAeCa9PQcoDIK" 
title="YouTube video player" 
frameborder="0" 
allow="accelerometer; 
clipboard-write;
encrypted-media; 
gyroscope; 
picture-in-picture; 
web-share" referrerpolicy="strict-origin-when-cross-origin" 
allowfullscreen></iframe>
</div>

## Reflections

In hindsight, writing custom firmware was the wrong choice *for the constraints
of this sprint*, even though it was technically feasible. The project required
us to just use electronics in some way and our Arduino, stepper motors, and 
limit switches covered that easily.

What I should have done is used [grbl](https://github.com/grbl/grbl) to
interpret g-code that could be generated by any number of ready-made desktop
tools. This would have allowed us to focus more on the mechanical design, allowed
for more parallel work across the team, reduced debugging surface area, and let
us present a more polished prototype at the end of the sprint.